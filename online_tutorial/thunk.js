//! createReducer()

// import { createAction, createReducer } from "@reduxjs/toolkit";

// const increment = createAction("counter/increment");
// const decrement = createAction("counter/decrement");
// const incrementByAmount = createAction("counter/incrementByAmount");

// const initialState = { value: 0 }

// const counterReducer = createReducer(initialState, (builder) => {
//   builder
//     .addCase(increment, (state, action) => {
//       state.value++
//     })
//     .addCase(decrement, (state, action) => {
//       state.value--
//     })
//     .addCase(incrementByAmount, (state, action) => {
//       state.value += action.payload
//     })
// })

//? Builder Methods
// builder.addCase
// Adds a case reducer to handle a single exact action type.

// All calls to builder.addCase must come before any calls to builder.addMatcher or builder.addDefaultCase.

//! Parameters
// actionCreator Either a plain action type string, or an action creator generated by createAction that can be used to determine the action type.
// reducer The actual case reducer function.
// builder.addMatcher
// Allows you to match your incoming actions against your own filter function instead of only the action.type property.

// If multiple matcher reducers match, all of them will be executed in the order they were defined in - even if a case reducer already matched. All calls to builder.addMatcher must come after any calls to builder.addCase and before any calls to builder.addDefaultCase.

// Parameters
// matcher A matcher function. In TypeScript, this should be a type predicate function
// reducer The actual case reducer function.

// import { createAction, createReducer } from '@reduxjs/toolkit'

// const initialState = {}
// const resetAction = createAction('reset-tracked-loading-state')

// function isPendingAction(action) {
//   return action.type.endsWith('/pending')
// }

// const reducer = createReducer(initialState, (builder) => {
//   builder
//     .addCase(resetAction, () => initialState)
//     // matcher can be defined outside as a type predicate function
//     .addMatcher(isPendingAction, (state, action) => {
//       state[action.meta.requestId] = 'pending'
//     })
//     .addMatcher(
//       // matcher can be defined inline as a type predicate function
//       (action) => action.type.endsWith('/rejected'),
//       (state, action) => {
//         state[action.meta.requestId] = 'rejected'
//       }
//     )
//     // matcher can just return boolean and the matcher can receive a generic argument
//     .addMatcher(
//       (action) => action.type.endsWith('/fulfilled'),
//       (state, action) => {
//         state[action.meta.requestId] = 'fulfilled'
//       }
//     )
// })

//?Redux Toolkit's RTK Query data fetching API is a purpose built data fetching and caching solution for
//  Redux apps, and can eliminate the need to write any thunks or reducers to manage data fetching.
// We encourage you to try it out and see if it can help simplify the data fetching code in your own apps!
// import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
// import { userAPI } from './userAPI'

// // First, create the thunk
// const fetchUserById = createAsyncThunk(
//   'users/fetchByIdStatus',
//   async (userId: number, thunkAPI) => {
//     const response = await userAPI.fetchById(userId)
//     return response.data
//   }
// )

// interface UsersState {
//   entities: []
//   loading: 'idle' | 'pending' | 'succeeded' | 'failed'
// }

// const initialState = {
//   entities: [],
//   loading: 'idle',
// } as UsersState

// // Then, handle actions in your reducers:
// const usersSlice = createSlice({
//   name: 'users',
//   initialState,
//   reducers: {
//     // standard reducer logic, with auto-generated action types per reducer
//   },
//   extraReducers: (builder) => {
//     // Add reducers for additional action types here, and handle loading state as needed
//     builder.addCase(fetchUserById.fulfilled, (state, action) => {
//       // Add user to the state array
//       state.entities.push(action.payload)
//     })
//   },
// })

// // Later, dispatch the thunk as needed in the app
// dispatch(fetchUserById(123))
